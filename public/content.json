[{"title":"hexo+github搭建自己的博客","date":"2017-04-08T07:08:32.000Z","path":"2017/04/08/hexo+github搭建自己的博客/","text":"之前很早就想用hexo弄一个自己独立的博客了，在博客园也写了很多的博客,不过不喜欢博客园的风格。不过今天，终于折腾成功了，用hexo搭建了一个在github写的博客，开心，后面会将自己以前的博客慢慢迁移过来。 前期准备工作 安装hexo npm install -g hexo 创建一个文件夹，如：myBog，cd到myBog里执行hexo init命令 执行hexo generate （hexo g 也可以） 执行hexo server hexo写博客的步骤新建一篇博客: 方法1： 1hexo new &quot;文章标题&quot; 方法2：在本地博客文件夹source-&gt;_post文件夹下看到我们新建的markdown文件 两者的效果是一样的 进行本地发布 执行命令 hexo server 浏览器打开：http://localhost:4000/ 部署到线上，执行三个命令 hexo clean hexo generate 也可以 hexo g hexo deploy或者直接执行 hexo c &amp;&amp; hexo g &amp;&amp; hexo d 一些常用命令hexo new &quot;postName&quot; #新建文章hexo new page &quot;pageName&quot; #新建页面hexo generate #生成静态页面至public目录hexo server #开启预览访问端口（默认端口4000，’ctrl + c’关闭server）hexo deploy #将.deploy目录部署到GitHubhexo help #查看帮助hexo version #查看Hexo的版本 小tips 问：如何让文章想只显示一部分和一个 阅读全文 的按钮？答：在文章中加一个 &lt;!--more--&gt; ， &lt;!--more--&gt; 后面的内容就不会显示出来了。 问：本地部署成功了，也能预览效果，但使用 username.github.io 访问，出现 404 .答：首先确认 hexo d 命令执行是否报错，如果没有报错，再查看一下你的 github 的 username.github.io 仓库，你的博客是否已经成功提交了，你的 github 邮箱也要通过验证才行。 如何更换主题分为以下个步骤： 选择主题:哪里选呢，可以在这里官方主题 安装主题： 将主题下载或者clone到你的站点目录的 themes 目录中，比如我要安装yilia主题，那么将改文件夹复制到themes中，即为 themes/yilia 打开 站点配置文件_config.yml，找到 theme 字段，并将其值更改为 yilia(你要安装的主题的文件夹名字) 。 验证主题是否启用: 运行 hexo s --debug ，并访问 http://localhost:4000 ，确保站点正确运行。 部署和发布到文章的步骤一样 头像设置在主题文件夹下的_config.yml中：avatar: https://avatars1.githubusercontent.com/u/32269?v=3&amp;s=460.比如我的是themes/yilia/_config.yml由于我用的是yilia主题，或者直接修改layout/_partial/left-col.ejs的第六行和第八行为：12&lt;img src=\"&lt;%=theme.avatar%&gt;\" class=\"js-avatar show\"&gt;&lt;img src=\"&lt;%=theme.avatar%&gt;\" class=\"js-avatar show\" style=\"width: 100%;height: 100%;opacity: 1;\"&gt; 添加阅读量计划使用 Lean Cloud 可以参考 这里 添加评论模块可以参考这篇文章：评论模块本博客中，因为多说已经不再维护了，友言不支持https，所以暂时没弄好评论模块,家里的网络访问不了disqus。所以评论模块待定，晚点再弄","tags":[{"name":"hexo","slug":"hexo","permalink":"https://xianyulaodi.github.io/tags/hexo/"},{"name":"github","slug":"github","permalink":"https://xianyulaodi.github.io/tags/github/"}]},{"title":"git常用命令总结","date":"2017-03-31T07:50:00.000Z","path":"2017/03/31/git常用命令总结/","text":"平时要用一些命令老是去网上找还挺麻烦的，所以总结起来，方便以后自己的查阅 正常的开发流程命令 首先进入项目的主分支 Fork一份工程，当做自己的项目管理分支&ensp;&ensp;&ensp;Fork的作用:&ensp;&ensp;&ensp;相当于你在原项目的主分支上又建立了一个分支，你可以在该分支上任意修改，如果想将你的修改合并到原项目中时，可以pull request，这样原项目的作者就可以将你修改的东西合并到原项目的主分支上去，这样你就为开源项目贡献了代码，开源项目就会在大家共同的努力下不断壮大和完善。 在电脑上创建一个文件夹，先Clone一份自己工程的项目分支(xxx屏蔽公司信息) 1Git clone git@xxxx.gitlab.com:xxxxxx/SELand_Vertu 进入项目的二级目录进入git客户端，确认要pull分支 git branch 看看当前的分支 git checkout -b develop 切换到develop分支，因为我要pull拉去develop分支上的项目 然后在将自己的项目分支同步项目主分支（我们项目分支为develop分支） 1git pull git@xxx.gitlab.com:xxx/SELand_Vertu develop 每次提交代码时候，需要先同步项目主分支代码 git status 是哪些文件有所修改 git diff 可以查询所修改的代码 git add -A 增加自己所做的修改 git commit -a 提交所有修改的代码 ，加注释是这样 git commit -a -m &quot;这里是注释的内容&quot; git push origin develop 提交代码,这里的提交只是提交到了项目的develop分支上面，还没提交到master上面 若代码有冲突，可以这样解决 git pull git@xxx.gitlab.com:xxx/SELand_Vertu develop 先同步一下会出现以上的错误 pull会使用git merge导致冲突，需要将冲突的文件resolve掉 git add -u, 在项目中看看哪些代码是对方改的，哪些代码是自己修改的，在合并成一份最新的代码 git commit 之后才能成功 添加修改 添加文件到暂缓区： git add -A .一次添加所有改变的文件 git add xx将xx文件添加到暂存区 git add . 添加新文件和编辑过的文件不包括删除的文件 git add -u 添加编辑或者删除的文件，不包括新添加的文件。 commit文件 git commit -m &quot;这里是注释&quot; 提交的是暂存区里面的内容，也就是 Changes to be committed 中的文件。 git commit -a -m &quot;这里是注释&quot; 除了将暂存区里的文件提交外，还提交 Changes bu not updated 中的文件。 git commit --amend有时候我们会发现有几个文件漏了提交或者想修改一下提交信息，又或者忘记使用 -a 选项导致一些文件没有被提交，我们希望对上一次提交进行修改，或者说取消上一次提交，这时候我们需要使用 –amend 选项。 git commit --amend -a用来当我们发现在提交时忘记使用 -a 选项，导致 Changes bu not updated 中的内容没有被提交 撤销修改1.撤销commit方法1:&ensp;&ensp;执行git log查看 commit日志，然后git reset --hard commit_idcommit_id是控制台上的hash值方法2:&ensp;&ensp;git reset –hard HEAD^,如果是上上一个版本git reset –hard HEAD^^,如果是上一百个版本git reset –hard HEAD~100;方法3:&ensp;&ensp;git checkout —-文件名 撤销对某个文件的修改,例：git checkout —-readme.txt；&ensp;&ensp;git checkout -- .撤销对所有文件的修改 ！！注意： 撤销之后，由于本地版本低于线上版本，想要提交代码，只能强行提交，覆盖线上，可以使用下面的命令：git push -f origin 分支名 2.恢复到某一版本现在我又发觉我最新的版本是没错的，我不想撤销了，我要回到最新版本，两步:git reflog查看历史版本；git reset –hard 版本号 3.撤销add&ensp;&ensp;git reset head &lt;文件名&gt; 撤销对某个文件的add命令&ensp;&ensp;git reset head . 撤销所有文件的add命令 创建与合并分支命令如下： 查看分支：git branch 创建分支：git branch name 切换分支：git checkout name 创建+切换分支：git checkout –b name 合并某分支到当前分支：git merge name 删除分支：git branch –d name github提交时想忽略某些文件比如我提交的时候，不想提交node_modules这个文件夹或者想忽略掉更多的文件夹，可以在github上或者在你的文件中添加.gitignore这个文件.gitignore里面的内容参考如下：1234567.DS_StoreThumbs.dbdb.json*.lognode_modules/public/.deploy*/ 本地文件想提交到远程 如果本地没有初始化git,在本地执行 git init git add -A .添加所有文件到暂缓区 git commit -a -m &quot;添加所有文件&quot; git remote add origin https://github.com/xianyulaodi/blogBackups.git。注意需要将origin后面换成自己的Git地址。 将本地仓库推送到远程仓库git push -u origin master第一次需要这样，以后只要执行git push origin master 关键！！在执行该命令时有时候会出错，原因是远程的文件未同步下来。此时可以先执行：git pull --rebase origin master将远程文件同步下来。然后在执行推送即可。完成后在后续的推送文件到远程仓库中可直接执行git push origin master可以看看这里 git常用命令 创建一个空目录 XX指目录名mkdir XX 显示当前目录的路径pwd 把当前的目录变成可以管理的git仓库，生成隐藏.git文件git init 把xx文件添加到暂存区去git add XX 提交文件 –m 后面的是注释git commit –m &quot;XX&quot; 查看仓库状态 git status 查看XX文件修改了那些内容 git diff XX 查看历史记录 git log 回退到上一个版本 git reset –hard HEAD^ 或者 git reset –hard HEAD~如果想回退到100个版本，使用git reset –hard HEAD~100 查看XX文件内容 cat XX 查看历史记录的版本号id git reflog 把XX文件在工作区的修改全部撤销 git checkout --XX 删除XX文件 git rm XX 关联一个远程库 git remote add origin https://github.com/xx 把当前master分支推送到远程库 git push –u(第一次要用-u 以后不需要) origin master 从远程库中克隆 git clone https://github.com/xx 创建dev分支 并切换到dev分支上 git checkout –b dev 查看当前所有的分支 git branch 切换回master分支 git checkout master 在当前的分支上合并dev分支 git merge dev 删除dev分支 git branch –d dev 创建分支 git branch name 把当前的工作隐藏起来 等以后恢复现场后继续工作 git stash 查看所有被隐藏的文件列表git stash list 恢复被隐藏的文件，但是内容不删除git stash apply 删除被隐藏文件 git stash drop 恢复文件的同时 也删除文件 git stash pop 查看远程库的信息git remote 查看远程库的详细信息 git remote –v 把master分支推送到远程库对应的远程分支上 git push origin master 把分支推送到远程的分支git push origin develop","tags":[{"name":"git","slug":"git","permalink":"https://xianyulaodi.github.io/tags/git/"}]},{"title":"使用vue2+vue-router+vuex写一个cnode的脚手架","date":"2017-03-29T12:46:00.000Z","path":"2017/03/29/使用vue2+vue-router+vuex写一个cnode的脚手架/","text":"&ensp;&ensp;公司后面的H5项目打算用vue2来做，之前有用过一小会vue，但没有真正的去了解，之前框架来说用react用的比较多点。所以趁这个阶段，用cnode中文网提供的api来做了个入门的脚手架，如果脚手架搭好并理解了，那么后面的运用就轻松多了。 本项目github地址 点击这里 &ensp;&ensp;vue目前在中国来说应该是属于最火的一个前端框架吧，当然，对框架还是一样的态度，如果项目中要用，就去研究它，否则，只需要去了解它。因为之前有react的一些项目经验，而且两者有一些共同性，所以vue的入门来说还是相当比较容易的，主要做的是勤查文档。 &ensp;&ensp;由于时间有限，没有对cnode中文网进行完全的重构，只重构了首页和详情页，因为这样比较容易理解，如果整个重构了，对于初学来说，比较难看懂，完成后的界面如图所示:(没怎么搞样式，界面巨丑) 首页&ensp;&ensp;详情页 项目简介基于vue.js的前端开发环境，用于前后端开发的单页面应用，可以在开发的时候使用ES2015 、scss等。项目包含： 基础库：vue.js、 vue-router2.0版本、vuex、axios 编译/打包工具：webpack、babel、node-sass 单元测试工具：karma、mocha、sinon-chai 本地服务器：express 运行方式 开发环境 npm install 点击start.sh、或者直接cmd里面输入 npm run dev 配置构建项目，构建好的文件会输出到 “dist” 目录， npm run build 服务器，可以查看构建的页面 npm run build-server 单元测试 npm run unit 项目说明&ensp;&ensp;之前玩react比较多，因为在新公司有些项目打算用vue，所以打算也来玩玩vue,不过是直接入手vue2,为了怕自己忘记，所以打算来个小小的总结,不过本文是一篇大杂烩，因为要写vue、vue-router和vuex这三者 vue组件的生命周期&ensp;&ensp;如果你之前有玩过react，那么就可以拿这些生命周期和react的进行一个类比了。组件的生命周期图如下： 如何写一个组件&ensp;&ensp;vue的读音和view同音，和react一样，也是组件化的一个理想框架，vue中组件化是如何实现的呢？我们以我们的项目为例 我们的项目中，首页的列表就有用到组件 indexItem组件,代码如下：component/indexItem.vue 123456789101112131415161718192021222324252627282930313233343536&lt;template&gt; &lt;div class=\"item-list-wrap\"&gt; &lt;ul class=\"item-list\"&gt; &lt;li v-for=\"item in itemList\"&gt; &lt;router-link :to=\"&#123;name:'detail',params:&#123;id:item.id&#125;&#125;\" &gt;&#123;&#123; item.title &#125;&#125;&lt;/router-link&gt; &lt;/li&gt; &lt;/ul&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123; props: ['itemList'], mounted: function () &#123; &#125;&#125;&lt;/script&gt;&lt;style lang=\"scss\" rel=\"stylesheet/scss\"&gt;.item-list-wrap&#123; background: #fff; .item-list li&#123; height: 45px; line-height: 45px; text-align: left; padding:0 10px; font-size: 14px; overflow: hidden; text-overflow: ellipsis; white-space:nowrap; border-bottom: 1px solid #ccc; &#125;&#125;&lt;/style&gt; &ensp;&ensp;我们定义了一个template模板，template数据名称来源于props，所有我们template使用for循环的时候，用的itemList，因为props里面写的是itemList.那么父组件如何调用这些组件呢，使用方法如下：views/index.vue123456789101112131415161718192021222324252627&lt;template&gt; &lt;div&gt; &lt;c-header :hTitle=\"title\"&gt;&lt;/c-header&gt; &lt;index-item :item-list='topicsListData'&gt;&lt;/index-item&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; import cHeader from 'components/header'; import indexItem from 'components/indexItem'; export default &#123; data () &#123; return &#123; title: 'node中文网', tabId:0 &#125; &#125;, computed: mapGetters(&#123; topicsListData :'getTopicsListData' &#125;), methods: &#123; components: &#123;cHeader,indexItem&#125; &#125;&lt;/script&gt; &ensp;&ensp;如上面的代码所示，我们import我们需要的组件，这里有个注意点，调用组件的时候，不支持驼峰命名法，所以你引用的驼峰命名的组件要拆开，比如引入的是indexItem组件，那么在使用的时候要拆成index-item。 &ensp;&ensp;如何传入数据呢。：[组件props的数据命名]，比如我的indexItem组件中，它的props里面的数据名字为 itemList,所以我父组件传值的时候，也是这样，通过 1&lt;index-item :item-list=传入的数据&gt;&lt;/index-item&gt; &ensp;&ensp;和引入组件一样，如果组件里面的props的命名是驼峰命名方式的话，也是需要拆开的。这里还有个需要注意点，我们不必在全局注册每个组件。通过使用组件实例选项注册，可以使组件仅在另一个实例/组件的作用域中可用。所以我们的项目中，我们应用了什么组件，在compontents里面就要写上对应的组件名称。如代码 1components: &#123;cHeader,indexItem&#125; vur-router 我这边使用的是vue-router2.0版本，遇到了一个坑，就是vue-router跳转之后，再回来，会刷新一次页面。比如我从a页面跳转到b页面，再从b页面返回a页面，那么a页面会刷新一次。这样存在的一个问题就是，我a页面又必须再请求一次数据，或者说，我a页面上传浏览的状态不能够保存。现在还没有找到很好的解决办法，包括使用html5的本地存储也没能很好的解决这个问题。 传参之后，改页面如何获取传过来的参数呢，可以用这个方法，比如我在router中传了一个id到b页面，那么b页面使用的时候可以用下面的代码来获取1this.$route.params.id 关于vue-router就介绍这些，因为可以看文档或者看代码就可以了解完，难度不是很大 vuex2.0&ensp;&ensp;刚开始看了vuex的文档，发觉跟redux很像，因为它确实有参照redux的思想来写，后来在使用过程中，发觉vuex还是跟redux有挺大的不同的。不过两者的一个相同点就是都是属于状态管理器，只有当你的页面有足够多的状态的时候才需要使用，否则没必要用，小项目用vuex之后增加代码的复杂性而已。 这里稍作解释：(个人理解，有误之处，欢迎指出) vuex也是跟redux一样，有且只能由一个store 在vuex中，状态的改变只能是通过mutations 用户改变状态有两种方式：第一种是触发action,然后action再来触发mutations;第二种方式是用户直接出发mutations mutations只能处理同步的状态，而action既能处理同步，也能处理异步,这也是action存在的理由，一般异步的状态管理交给action去做即可，同步的话可以直接触发mutations 触发action用dispatch、触发mutations用commit 这里介绍一下vuex异步的操作&ensp;&ensp;跟redux一样，理解异步状态管理还是比较难的，不过当你理解了异步的操作，你也就基本掌握vuex了。&ensp;&ensp;假设我有一个异步请求，需要请求后台的数据，那么需要怎么做呢？1234567891011121314151617181920212223242526272829303132333435363738import Vue from 'vue';import axios from 'axios';import * as types from '../../constants/constants';const state = &#123; topicsList:[]&#125;;const getters = &#123; getTopicsListData: state =&gt; state.topicsList&#125;;const actions = &#123; /** * @name 获取主页数据 * 异步的操作交给action,然后将获取到的数据 commit 到 mutations那里去 * * # 注意点： * 坑点：vuex2只能有两个参数，所以如果你的第二个参数中有多个参数，可以用对象的形式,实际的项目中貌似通过router中来传的，待定 */ [types.GET_TOPICS](&#123;commit&#125;,obj) &#123; axios.get(`https://cnodejs.org/api/v1/topics?page=$&#123;obj.pageNo&#125;&amp;limit=20&amp;tab=$&#123;obj.tab&#125;`) .then((response) =&gt; &#123; commit(types.SET_TOPICS, &#123; list: response.data.data &#125;) &#125;, (err) =&gt; &#123; console.log(err) &#125;) &#125; &#125;const mutations = &#123; // 获取首页的数据 [types.SET_TOPICS](state,&#123;list&#125;) &#123; state.topicsList=list; //再次记住，mutations是唯一允许更新应用状态的地方 &#125;&#125;;export default&#123; state, getters, actions, mutations&#125; &ensp;&ensp;如上面的代码所示，我们通过axios来发送我们的请求，具体的流程如下： 我们定义了一个默认的状态topicsList，并赋值为一个空数组 我们定义了一个action来获取后端数据， [types.GET_TOPICS]({commit},obj) {},其实这里也可以直接用方法名，只是vuex遵循flux的写法。也就是说这里其实也是可以写成getTopics({commit},obj) {}这种形式的。action的方法里，只能由两个参数，一个是默认的commmit,一个是其他参数，所以当你的异步请求有多个参数的时候，需要把它封装到一个对象或者数组里面。 我们在前面定义了一个默认的装填topicsList,前面也说了，状态的改变只能交给mutations来做，所以action获取到的数据，如果要传到topicsList这个状态中，必须要先交给mutations，再由mutations来更新topicsList。所以，获取到后端返回的数据之后，我们commit给mutations，然后mutations再来更新topicsList这个状态 在上面的代码中，我们有看到getters，干嘛用的呢？有一种情况是这样的，比如我渲染一个页面的时候，页面已经渲染完了，但是你的请求数据是异步的，数据还没有回来，那怎么办呢？getters就是这个作用的。我们将mutations更新的状态，传给getters,在getters里面，你可以对这些数据进行一些处理，然后再交给页面使用。 页面是如何使用传回来的数据的？ 在view/index.vue中，我们看下面的代码，代码是被简化的，只展示出有用的部分 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051 &lt;template&gt; &lt;div&gt; &lt;index-item :item-list='topicsListData'&gt;&lt;/index-item&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; import Vue from 'vue'; import &#123;mapState&#125; from 'vuex'; import &#123;mapGetters&#125; from 'vuex'; import indexItem from 'components/indexItem'; import * as types from '../constants/constants'; export default &#123; data () &#123; return &#123; title: 'node中文网' &#125; &#125;, // computed相当于属性的一个实时计算，里面的数据如果有变化，会自动去更新 computed: mapGetters(&#123; topicsListData :'getTopicsListData' &#125;), methods: &#123; /* * @获取内容 */ getTopics (page,tab,index) &#123; // 触发action this.$store.dispatch(&#123; type:types.GET_TOPICS, pageNo:page, tab:tab &#125;); this.tabId=index; &#125;, &#125;, /* * @初始化(组件挂载完成)，相当于react中的componentWillamount */ mounted () &#123; this.getTopics(1,'all'); &#125;, components: &#123;indexItem&#125; &#125;&lt;/script&gt; &ensp;&ensp;我们可以看到，在代码中，我们定义了一个方法 getTopics，它的作用是发送一个action,并传一些参数进去。页面初始化的时候，我们执行这个方法。也就是mounted里面，我们执行了getTopics这个函数。&ensp;&ensp;我们还看到，代码中，我们在computed里面执行了mapGetters，并在里面写入了getters对象，如代码所示：&ensp;&ensp;123computed: mapGetters(&#123; topicsListData :'getTopicsListData'&#125;), &ensp;&ensp;这里稍作解释，computed的作用就是：它相当于一个实时计算，如果里面的内容对应的数据有变化，就会去自动更新里面的数据，并且重新渲染。而mapGetters是映射对应的getters，代码以键值对的形式： topicsListData :&#39;getTopicsListData &ensp;&ensp;其中指要和getters里面定义的相对应。比如我getter定义的值为getTopicsListData，mapGetters里面对象的值也要写为getTopicsListData。 &ensp;&ensp;而topicsListData则是你需要传到组件中的数据，如下所示 &lt;index-item :item-list=&#39;topicsListData&#39;&gt;&lt;/index-item&gt;; 在异步获取的数据中，如果要传给组件，只能从gettter这里去拿，不然是获取不到后端返回的数据的。因为有一个先后的问题 后记 对于vue2和vue-router2.0以及vuex2的总结就先到这里，主要是自己在第一次使用中遇到的问题。 后面将进入实战阶段，不过脚手架搭好了，后面的问题就是一直参考文档和埋坑就可以了。 当然，因为对vue2的认识时间不是特别长，所以这篇文章难免有些错误，有误之处，欢迎指出","tags":[{"name":"vue","slug":"vue","permalink":"https://xianyulaodi.github.io/tags/vue/"},{"name":"vuex","slug":"vuex","permalink":"https://xianyulaodi.github.io/tags/vuex/"},{"name":"vue-router","slug":"vue-router","permalink":"https://xianyulaodi.github.io/tags/vue-router/"}]},{"title":"老生常谈-从输入url到页面展示到底发生了什么","date":"2017-03-22T12:07:00.000Z","path":"2017/03/22/老生常谈-从输入url到页面展示到底发生了什么/","text":"&ensp;&ensp;&ensp;&ensp; 刚开始写这篇文章还是挺纠结的，因为网上搜索“从输入url到页面展示到底发生了什么”，你可以搜到一大堆的资料。而且面试这道题基本是必考题，二月份面试的时候，虽然知道这个过程发生了什么，不过当面试官一步步追问下去的，很多细节就不太清楚了。 &ensp;&ensp;&ensp;&ensp;最近刚好也在看http协议相关的东西，所以想对这个话题来个深入的总结，本文的目的是通过输入url之后发生的事情来做知识的总结和扩展。所以文章可能会很杂。 总的过程大概如下: 1、输入地址 &ensp;&ensp;&ensp;&ensp;当我们开始在浏览器中输入网址的时候，浏览器其实就已经在智能的匹配可能得url了，他会从历史记录，书签等地方，找到已经输入的字符串可能对应的 url，然后给出智能提示，让你可以补全url地址。对于google的chrome的浏览器，他甚至会直接从缓存中把网页展示出来，就是说，你还没有按下 enter，页面就出来了。 2、浏览器查找域名的 IP 地址 &ensp;&ensp;&ensp;&ensp; 1、请求一旦发起，浏览器首先要做的事情就是解析这个域名，一般来说，浏览器会首先查看本地硬盘的 hosts 文件，看看其中有没有和这个域名对应的规则，如果有的话就直接使用 hosts 文件里面的 ip 地址。&ensp;&ensp;&ensp;&ensp; 2、如果在本地的 hosts 文件没有能够找到对应的 ip 地址，浏览器会发出一个 DNS请求到本地DNS服务器 。本地DNS服务器一般都是你的网络接入服务器商提供，比如中国电信，中国移动。&ensp;&ensp;&ensp;&ensp; 3、查询你输入的网址的DNS请求到达本地DNS服务器之后，本地DNS服务器会首先查询它的缓存记录，如果缓存中有此条记录，就可以直接返回结果，此过程是递归的方式进行查询。如果没有，本地DNS服务器还要向DNS根服务器进行查询。&ensp;&ensp;&ensp;&ensp;4、根DNS服务器没有记录具体的域名和IP地址的对应关系，而是告诉本地DNS服务器，你可以到域服务器上去继续查询，并给出域服务器的地址。这种过程是迭代的过程。&ensp;&ensp;&ensp;&ensp;5、本地DNS服务器继续向域服务器发出请求，在这个例子中，请求的对象是.com域服务器。.com域服务器收到请求之后，也不会直接返回域名和IP地址的对应关系，而是告诉本地DNS服务器，你的域名的解析服务器的地址。&ensp;&ensp;&ensp;&ensp;6、最后，本地DNS服务器向域名的解析服务器发出请求，这时就能收到一个域名和IP地址对应关系，本地DNS服务器不仅要把IP地址返回给用户电脑，还要把这个对应关系保存在缓存中，以备下次别的用户查询时，可以直接返回结果，加快网络访问。下面这张图很完美的解释了这一过程： —-知识扩展—- 1)什么是DNS？ DNS（Domain Name System，域名系统），因特网上作为域名和IP地址相互映射的一个分布式数据库，能够使用户更方便的访问互联网，而不用去记住能够被机器直接读取的IP数串。通过主机名，最终得到该主机名对应的IP地址的过程叫做域名解析（或主机名解析）。 通俗的讲，我们更习惯于记住一个网站的名字，比如www.baidu.com,而不是记住它的ip地址，比如：167.23.10.2。而计算机更擅长记住网站的ip地址，而不是像www.baidu.com等链接。因为，DNS就相当于一个电话本，比如你要找www.baidu.com这个域名，那我翻一翻我的电话本，我就知道，哦，它的电话（ip）是167.23.10.2。 2)DNS查询的两种方式：递归查询和迭代查询 1、递归解析 当局部DNS服务器自己不能回答客户机的DNS查询时，它就需要向其他DNS服务器进行查询。此时有两种方式，如图所示的是递归方式。局部DNS服务器自己负责向其他DNS服务器进行查询，一般是先向该域名的根域服务器查询，再由根域名服务器一级级向下查询。最后得到的查询结果返回给局部DNS服务器，再由局部DNS服务器返回给客户端。 2、迭代解析 当局部DNS服务器自己不能回答客户机的DNS查询时，也可以通过迭代查询的方式进行解析，如图所示。局部DNS服务器不是自己向其他DNS服务器进行查询，而是把能解析该域名的其他DNS服务器的IP地址返回给客户端DNS程序，客户端DNS程序再继续向这些DNS服务器进行查询，直到得到查询结果为止。也就是说，迭代解析只是帮你找到相关的服务器而已，而不会帮你去查。比如说：baidu.com的服务器ip地址在192.168.4.5这里，你自己去查吧，本人比较忙，只能帮你到这里了。 3)DNS域名称空间的组织方式 我们在前面有说到根DNS服务器，域DNS服务器，这些都是DNS域名称空间的组织方式。按其功能命名空间中用来描述 DNS 域名称的五个类别的介绍详见下表中，以及与每个名称类型的示例 4)DNS负载均衡 当一个网站有足够多的用户的时候，假如每次请求的资源都位于同一台机器上面，那么这台机器随时可能会蹦掉。处理办法就是用DNS负载均衡技术，它的原理是在DNS服务器中为同一个主机名配置多个IP地址,在应答DNS查询时,DNS服务器对每个查询将以DNS文件中主机记录的IP地址按顺序返回不同的解析结果,将客户端的访问引导到不同的机器上去,使得不同的客户端访问不同的服务器,从而达到负载均衡的目的｡例如可以根据每台机器的负载量，该机器离用户地理位置的距离等等。 3、浏览器向 web 服务器发送一个 HTTP 请求 拿到域名对应的IP地址之后，浏览器会以一个随机端口（1024&lt;端口&lt;65535）向服务器的WEB程序（常用的有httpd,nginx等）80端口发起TCP的连接请求。这个连接请求到达服务器端后（这中间通过各种路由设备，局域网内除外），进入到网卡，然后是进入到内核的TCP/IP协议栈（用于识别该连接请求，解封包，一层一层的剥开），还有可能要经过Netfilter防火墙（属于内核的模块）的过滤，最终到达WEB程序，最终建立了TCP/IP的连接。 TCP连接如图所示: 建立了TCP连接之后，发起一个http请求。一个典型的 http request header 一般需要包括请求的方法，例如 GET 或者 POST 等，不常用的还有 PUT 和 DELETE 、HEAD、OPTION以及 TRACE 方法，一般的浏览器只能发起 GET 或者 POST 请求。 客户端向服务器发起http请求的时候，会有一些请求信息，请求信息包含三个部分： 请求方法URI协议/版本 请求头(Request Header) 请求正文： 下面是一个完整的HTTP请求例子：123456789GET/sample.jspHTTP/1.1Accept:image/gif.image/jpeg,*/*Accept-Language:zh-cnConnection:Keep-AliveHost:localhostUser-Agent:Mozila/4.0(compatible;MSIE5.01;Window NT5.0)Accept-Encoding:gzip,deflateusername=jinqiao&amp;password=1234 注意：最后一个请求头之后是一个空行，发送回车符和换行符，通知服务器以下不再有请求头。 （1）请求的第一行是“方法URL议/版本”：GET/sample.jsp HTTP/1.1（2）请求头(Request Header) 请求头包含许多有关的客户端环境和请求正文的有用信息。例如，请求头可以声明浏览器所用的语言，请求正文的长度等。123456Accept:image/gif.image/jpeg.*/*Accept-Language:zh-cnConnection:Keep-AliveHost:localhostUser-Agent:Mozila/4.0(compatible:MSIE5.01:Windows NT5.0)Accept-Encoding:gzip,deflate. （3）请求正文 请求头和请求正文之间是一个空行，这个行非常重要，它表示请求头已经结束，接下来的是请求正文。请求正文中可以包含客户提交的查询字符串信息： username=jinqiao&amp;password=1234 —- 知识扩展—- 1）TCP三次握手 第一次握手：客户端A将标志位SYN置为1,随机产生一个值为seq=J（J的取值范围为=1234567）的数据包到服务器，客户端A进入SYN_SENT状态，等待服务端B确认； 第二次握手：服务端B收到数据包后由标志位SYN=1知道客户端A请求建立连接，服务端B将标志位SYN和ACK都置为1，ack=J+1，随机产生一个值seq=K，并将该数据包发送给客户端A以确认连接请求，服务端B进入SYN_RCVD状态。 第三次握手：客户端A收到确认后，检查ack是否为J+1，ACK是否为1，如果正确则将标志位ACK置为1，ack=K+1，并将该数据包发送给服务端B，服务端B检查ack是否为K+1，ACK是否为1，如果正确则连接建立成功，客户端A和服务端B进入ESTABLISHED状态，完成三次握手，随后客户端A与服务端B之间可以开始传输数据了。 如图所示： 2）为什需要三次握手？&ensp;&ensp;&ensp;&ensp;《计算机网络》第四版中讲“三次握手”的目的是“为了防止已失效的连接请求报文段突然又传送到了服务端，因而产生错误”&ensp;&ensp;&ensp;&ensp;书中的例子是这样的，“已失效的连接请求报文段”的产生在这样一种情况下：client发出的第一个连接请求报文段并没有丢失，而是在某个网络结点长时间的滞留了，以致延误到连接释放以后的某个时间才到达server。本来这是一个早已失效的报文段。但server收到此失效的连接请求报文段后，就误认为是client再次发出的一个新的连接请求。于是就向client发出确认报文段，同意建立连接。&ensp;&ensp;&ensp;&ensp;假设不采用“三次握手”，那么只要server发出确认，新的连接就建立了。由于现在client并没有发出建立连接的请求，因此不会理睬server的确认，也不会向server发送数据。但server却以为新的运输连接已经建立，并一直等待client发来数据。这样，server的很多资源就白白浪费掉了。采用“三次握手”的办法可以防止上述现象发生。例如刚才那种情况，client不会向server的确认发出确认。server由于收不到确认，就知道client并没有要求建立连接。”。主要目的防止server端一直等待，浪费资源。 3）TCP四次挥手 第一次挥手：Client发送一个FIN，用来关闭Client到Server的数据传送，Client进入FIN_WAIT_1状态。 第二次挥手：Server收到FIN后，发送一个ACK给Client，确认序号为收到序号+1（与- SYN相同，一个FIN占用一个序号），Server进入CLOSE_WAIT状态。 第三次挥手：Server发送一个FIN，用来关闭Server到Client的数据传送，Server进入LAST_ACK状态。 第四次挥手：Client收到FIN后，Client进入TIME_WAIT状态，接着发送一个ACK给Server，确认序号为收到序号+1，Server进入CLOSED状态，完成四次挥手。 4）为什么建立连接是三次握手，而关闭连接却是四次挥手呢？ 这是因为服务端在LISTEN状态下，收到建立连接请求的SYN报文后，把ACK和SYN放在一个报文里发送给客户端。而关闭连接时，当收到对方的FIN报文时，仅仅表示对方不再发送数据了但是还能接收数据，己方也未必全部数据都发送给对方了，所以己方可以立即close，也可以发送一些数据给对方后，再发送FIN报文给对方来表示同意现在关闭连接，因此，己方ACK和FIN一般都会分开发送。 4、服务器的永久重定向响应 服务器给浏览器响应一个301永久重定向响应，这样浏览器就会访问http://www.google.com/ 而非http://google.com/。 为什么服务器一定要重定向而不是直接发送用户想看的网页内容呢？其中一个原因跟搜索引擎排名有关。如果一个页面有两个地址，就像http://www.yy.com/和http://yy.com/，搜索引擎会认为它们是两个网站，结果造成每个搜索链接都减少从而降低排名。而搜索引擎知道301永久重定向是什么意思，这样就会把访问带www的和不带www的地址归到同一个网站排名下。还有就是用不同的地址会造成缓存友好性变差，当一个页面有好几个名字时，它可能会在缓存里出现好几次。 —-扩展知识—- 1）301和302的区别。 301和302状态码都表示重定向，就是说浏览器在拿到服务器返回的这个状态码后会自动跳转到一个新的URL地址，这个地址可以从响应的Location首部中获取（用户看到的效果就是他输入的地址A瞬间变成了另一个地址B）——这是它们的共同点。 他们的不同在于。301表示旧地址A的资源已经被永久地移除了（这个资源不可访问了），搜索引擎在抓取新内容的同时也将旧的网址交换为重定向之后的网址； 302表示旧地址A的资源还在（仍然可以访问），这个重定向只是临时地从旧地址A跳转到地址B，搜索引擎会抓取新的内容而保存旧的网址。 SEO302好于301 2）重定向原因：（1）网站调整（如改变网页目录结构）；（2）网页被移到一个新地址；（3）网页扩展名改变(如应用需要把.php改成.Html或.shtml)。 这种情况下，如果不做重定向，则用户收藏夹或搜索引擎数据库中旧地址只能让访问客户得到一个404页面错误信息，访问流量白白丧失；再者某些注册了多个域名的网站，也需要通过重定向让访问这些域名的用户自动跳转到主站点等。 3）什么时候进行301或者302跳转呢？&ensp;&ensp;&ensp;&ensp;当一个网站或者网页24—48小时内临时移动到一个新的位置，这时候就要进行302跳转，而使用301跳转的场景就是之前的网站因为某种原因需要移除掉，然后要到新的地址访问，是永久性的。清晰明确而言：使用301跳转的大概场景如下： 域名到期不想续费（或者发现了更适合网站的域名），想换个域名。 在搜索引擎的搜索结果中出现了不带www的域名，而带www的域名却没有收录，这个时候可以用301重定向来告诉搜索引擎我们目标的域名是哪一个。 空间服务器不稳定，换空间的时候。 5、浏览器跟踪重定向地址 现在浏览器知道了 &quot;http://www.google.com/&quot;才是要访问的正确地址，所以它会发送另一个http请求。这里没有啥好说的 6、服务器处理请求 经过前面的重重步骤，我们终于将我们的http请求发送到了服务器这里，其实前面的重定向已经是到达服务器了，那么，服务器是如何处理我们的请求的呢？ 后端从在固定的端口接收到TCP报文开始，它会对TCP连接进行处理，对HTTP协议进行解析，并按照报文格式进一步封装成HTTP Request对象，供上层使用。 一些大一点的网站会将你的请求到反向代理服务器中，因为当网站访问量非常大，网站越来越慢，一台服务器已经不够用了。于是将同一个应用部署在多台服务器上，将大量用户的请求分配给多台机器处理。此时，客户端不是直接通过HTTP协议访问某网站应用服务器，而是先请求到Nginx，Nginx再请求应用服务器，然后将结果返回给客户端，这里Nginx的作用是反向代理服务器。同时也带来了一个好处，其中一台服务器万一挂了，只要还有其他服务器正常运行，就不会影响用户使用。 如图所示： 通过Nginx的反向代理，我们到达了web服务器，服务端脚本处理我们的请求，访问我们的数据库，获取需要获取的内容等等，当然，这个过程涉及很多后端脚本的复杂操作。由于对这一块不熟，所以这一块只能介绍这么多了。 —-扩展阅读—- 1）什么是反向代理？&ensp;&ensp;&ensp;&ensp;客户端本来可以直接通过HTTP协议访问某网站应用服务器，网站管理员可以在中间加上一个Nginx，客户端请求Nginx，Nginx请求应用服务器，然后将结果返回给客户端，此时Nginx就是反向代理服务器。 7、服务器返回一个 HTTP 响应 经过前面的6个步骤，服务器收到了我们的请求，也处理我们的请求，到这一步，它会把它的处理结果返回，也就是返回一个HTPP响应。HTTP响应与HTTP请求相似，HTTP响应也由3个部分构成，分别是： 状态行 响应头(Response Header) 响应正文12345678910111213HTTP/1.1 200 OKDate: Sat, 31 Dec 2005 23:59:59 GMTContent-Type: text/html;charset=ISO-8859-1Content-Length: 122＜html＞＜head＞＜title＞http＜/title＞＜/head＞＜body＞＜!-- body goes here --＞＜/body＞＜/html＞ 状态行： 状态行由协议版本、数字形式的状态代码、及相应的状态描述，各元素之间以空格分隔。格式: HTTP-Version Status-Code Reason-Phrase CRLF例如: HTTP/1.1 200 OK \\r\\n| -协议版本：是用http1.0还是其他版本| -状态描述：状态描述给出了关于状态代码的简短的文字描述。比如状态代码为200时的描述为 ok| -态代码：状态代码由三位数字组成，第一个数字定义了响应的类别，且有五种可能取值。如下 1xx：信息性状态码，表示服务器已接收了客户端请求，客户端可继续发送请求。 100 Continue 101 Switching Protocols 2xx：成功状态码，表示服务器已成功接收到请求并进行处理。 200 OK 表示客户端请求成功 204 No Content 成功，但不返回任何实体的主体部分 206 Partial Content 成功执行了一个范围（Range）请求 3xx： 重定向状态码，表示服务器要求客户端重定向。 301 Moved Permanently 永久性重定向，响应报文的Location首部应该有该资源的新URL 302 Found 临时性重定向，响应报文的Location首部给出的URL用来临时定位资源 303 See Other 请求的资源存在着另一个URI，客户端应使用GET方法定向获取请求的资源 304 Not Modified 服务器内容没有更新，可以直接读取浏览器缓存 307 Temporary Redirect 临时重定向。与302 Found含义一样。302禁止POST变换为GET，但实际使用时并不一定，307则更多浏览器可能会遵循这一标准，但也依赖于浏览器具体实现 4xx：客户端错误状态码，表示客户端的请求有非法内容。 400 Bad Request 表示客户端请求有语法错误，不能被服务器所理解 401 Unauthonzed 表示请求未经授权，该状态代码必须与 WWW-Authenticate 报头域一起使用 403 Forbidden 表示服务器收到请求，但是拒绝提供服务，通常会在响应正文中给出不提供服务的原因 404 Not Found 请求的资源不存在，例如，输入了错误的URL 5xx：服务器错误状态码，表示服务器未能正常处理客户端的请求而出现意外错误。 500 Internel Server Error 表示服务器发生不可预期的错误，导致无法完成客户端的请求 503 Service Unavailable 表示服务器当前不能够处理客户端的请求，在一段时间之后，服务器可能会恢复正常 响应头： 响应头部：由关键字/值对组成，每行一对，关键字和值用英文冒号”:”分隔，典型的响应头有： 响应正文包含着我们需要的一些具体信息，比如cookie，html,image，后端返回的请求数据等等。这里需要注意，响应正文和响应头之间有一行空格，表示响应头的信息到空格为止，下图是fiddler抓到的请求正文，红色框中的：响应正文： 8、浏览器显示 HTML 在浏览器没有完整接受全部HTML文档时，它就已经开始显示这个页面了，浏览器是如何把页面呈现在屏幕上的呢？不同浏览器可能解析的过程不太一样，这里我们只介绍webkit的渲染过程，下图对应的就是WebKit渲染的过程，这个过程包括： 解析html以构建dom树 -&gt; 构建render树 -&gt; 布局render树 -&gt; 绘制render树 浏览器在解析html文件时，会”自上而下“加载，并在加载过程中进行解析渲染。在解析过程中，如果遇到请求外部资源时，如图片、外链的CSS、iconfont等，请求过程是异步的，并不会影响html文档进行加载。 解析过程中，浏览器首先会解析HTML文件构建DOM树，然后解析CSS文件构建渲染树，等到渲染树构建完成后，浏览器开始布局渲染树并将其绘制到屏幕上。这个过程比较复杂，涉及到两个概念: reflow(回流)和repain(重绘)。 DOM节点中的各个元素都是以盒模型的形式存在，这些都需要浏览器去计算其位置和大小等，这个过程称为relow;当盒模型的位置,大小以及其他属性，如颜色,字体,等确定下来之后，浏览器便开始绘制内容，这个过程称为repain。 页面在首次加载时必然会经历reflow和repain。reflow和repain过程是非常消耗性能的，尤其是在移动设备上，它会破坏用户体验，有时会造成页面卡顿。所以我们应该尽可能少的减少reflow和repain。 当文档加载过程中遇到js文件，html文档会挂起渲染（加载解析渲染同步）的线程，不仅要等待文档中js文件加载完毕，还要等待解析执行完毕，才可以恢复html文档的渲染线程。因为JS有可能会修改DOM，最为经典的document.write，这意味着，在JS执行完成前，后续所有资源的下载可能是没有必要的，这是js阻塞后续资源下载的根本原因。所以我明平时的代码中，js是放在html文档末尾的。 JS的解析是由浏览器中的JS解析引擎完成的，比如谷歌的是V8。JS是单线程运行，也就是说，在同一个时间内只能做一件事，所有的任务都需要排队，前一个任务结束，后一个任务才能开始。但是又存在某些任务比较耗时，如IO读写等，所以需要一种机制可以先执行排在后面的任务，这就是：同步任务(synchronous)和异步任务(asynchronous)。 JS的执行机制就可以看做是一个主线程加上一个任务队列(task queue)。同步任务就是放在主线程上执行的任务，异步任务是放在任务队列中的任务。所有的同步任务在主线程上执行，形成一个执行栈;异步任务有了运行结果就会在任务队列中放置一个事件；脚本运行时先依次运行执行栈，然后会从任务队列里提取事件，运行任务队列中的任务，这个过程是不断重复的，所以又叫做事件循环(Event loop)。具体的过程可以看我这篇文章：点击这里 9、浏览器发送请求获取嵌入在 HTML 中的资源（如图片、音频、视频、CSS、JS等等） 其实这个步骤可以并列在步骤8中，在浏览器显示HTML时，它会注意到需要获取其他地址内容的标签。这时，浏览器会发送一个获取请求来重新获得这些文件。比如我要获取外图片，CSS，JS文件等，类似于下面的链接：图片：http://static.ak.fbcdn.net/rsrc.php/z12E0/hash/8q2anwu7.gifCSS式样表：http://static.ak.fbcdn.net/rsrc.php/z448Z/hash/2plh8s4n.cssJavaScript 文件：http://static.ak.fbcdn.net/rsrc.php/zEMOA/hash/c8yzb6ub.js 这些地址都要经历一个和HTML读取类似的过程。所以浏览器会在DNS中查找这些域名，发送请求，重定向等等…不像动态页面，静态文件会允许浏览器对其进行缓存。有的文件可能会不需要与服务器通讯，而从缓存中直接读取，或者可以放到CDN中 ————————————————-分割线—————————————————– 至此，从输入url到页面展示的过程终于整理完了。本文前前后后整理了差不多一个星期，当然，网上有很多文章的顺序可能跟本文不太一样，也是可以的。 如今已离开呆了一年的大YY，进入了另一家公司，有很多东西在后面等着学习，有点小压力的同时也有很强烈的兴奋，哈哈。愿你在金三银四里找到满意的工作，干巴爹。 当然，文笔有限，有误之处，欢迎指出，本文参考了很多的文章，不过很多文章的链接不记得了，所以只列出了下面三个参考链接。 参考文献：https://segmentfault.com/a/1190000006879700http://igoro.com/archive/what-really-happens-when-you-navigate-to-a-url/http://zrj.me/archives/589","tags":[{"name":"博客园迁移","slug":"博客园迁移","permalink":"https://xianyulaodi.github.io/tags/博客园迁移/"}]},{"title":"cookie小结","date":"2017-03-12T04:18:00.000Z","path":"2017/03/12/cookie小结/","text":"前记：前段时间搞一个活动，开发的时间被严重压缩，忙到飞起，以致于都没怎么写文章了，内疚. 2月份参加了一场面试，有一些关于cookie的问题回答的不是很好，所以这篇文章我们来对cooKie做一个探讨和总结，查漏补缺。其实本文很早之前都写的差不多了，不过关于cookie跨域方面，查了比较多的资料，始终没有一个太好的结果，所以本文一直没有发布。 本文的很多内容都是参考网上的资料，可以说是好几篇资料的集合，毕竟是总结嘛，就是将自己觉得有用的东西集合在一起。 什么是cookie 官方定义：Netscape官方文档中的定义为，Cookie是指在HTTP协议下，服务器或脚本可以维护客户端计算机上信息的一种方式 。通俗地说，Cookie是一种能够让网站Web服务器把少量数据储存到客户端的硬盘或内存里，或是从客户端的硬盘里读取数据的一种技术。 Cookie文件则是指在浏览某个网站时，由Web服务器的CGI脚本创建的存储在浏览器客户端计算机上的一个小文本文件，其格式为：用户名@网站地址 ［数字］.txt。 再通俗一点的讲，由于HTTP是一种无状态的协议，服务器单从网络连接上无从知道客户身份。怎么办呢？就给客户端们颁发一个通行证，每人一个，无论谁访问都必须携带自己通行证。这样服务器就能从通行证上确认客户身份了。 cookie的作用 HTTP协议是一种无状态、无连接的协议，不能在服务器上保持一次会话的连续状态信息。Cookie的作用是记录用户的有关信息，它最根本的用途是帮助Web站点保存有关访问者的信息。如身份识别号码ID、密码、浏览过的网页、停留的时间、用户在Web站点购物的方式或用户访问该站点的次数等，当用户再次链接Web服务器时，浏览器读取Cookie信息并传递给Web站点。 cookie的属性我们先来看一张图： 在谷歌浏览器开发者模式中，我们可以看到网站的cookie，所以，相应的，我们就可以知道cookie的一些属性了，接下来介绍Cookie中的一些属性 如图所示，cookie具有的属性有 Name、value、Domain、path、Expires/Max-Age、Size、HTTP、Secure等等，我们接下来详细了解了解Name：该Cookie的名称，一旦创建，名称便不可更改value:该Cookie的值，如果值为Unicode字符，需要为字符编码,如果值为二进制数据，则需要使用BASE64编码domain：可以访问该Cookie的域名。如果设置为”.google.com”,则所有以”google.com”结尾的域名都可以访问该Cookie。注意第一个字符必须为“.”这个domain稍作解释： 非顶级域名，如二级域名或者三级域名，设置的cookie的domain只能为顶级域名或者二级域名或者三级域名本身，不能设置其他二级域名的cookie，否则cookie无法生成。 顶级域名只能设置domain为顶级域名，不能设置为二级域名或者三级域名，否则cookie无法生成。 二级域名能读取设置了domain为顶级域名或者自身的cookie，不能读取其他二级域名domain的cookie。所以要想cookie在多个二级域名中共享，需要设置domain为顶级域名，这样就可以在所有二级域名里面或者到这个cookie的值了。顶级域名只能获取到domain设置为顶级域名的cookie，其他domain设置为二级域名的无法获取。Path: path字段为可以访问此cookie的页面路径。 比如domain是abc.com, path是/detail，那么只有/detail 路径下的页面可以读取此cookie。Expires/Max-Age: 该Cookie失效时间，单位秒。如果为正数，则Cookie在maxAge秒之后失效。 如果为负数，该Cookie为临时Cookie，关闭浏览器即失效，浏览器也不会以任何形式保存Cookie. 如果为0，表示删除Cookie。默认是-1Size:cookie的大小http： cookie的httponly属性。若此属性为true，则只有在http请求头中会带有此cookie的信息，而不能通过document.cookie来访问此cookie。比如截图中的__jsluidsecure： 设置是否只能通过https来传递此条cookie cookie的特性1、一个浏览器针对一个网站最多存20个Cookie，浏览器一般只允许存放300个Cookie2、每个Cookie的长度不能超过4KB（稀缺）。但不同的浏览器实现的不同3、Cookie的不可跨域名性。 例如：Cookie在客户端是由浏览器来管理的，浏览器能够保证Google只会操作Google的Cookie而不会操作Baidu的Cookie，从而保证用户的隐私安全。 cookie的分类cookie有两种类型： 临时Cookie（会话Cookie） 永久Cookie 不设置过期时间，则表示这个cookie生命周期为浏览器会话期间，只要关闭浏览器窗口，cookie就消失了。这种生命期为浏览会话期的cookie被称为会话cookie。会话cookie一般不保存在硬盘上而是保存在内存里。可以类比于本地存储的sessionstore 设置了过期时间，浏览器就会把cookie保存到硬盘上，关闭后再次打开浏览器，这些cookie依然有效直到超过设定的过期时间。 存储在硬盘上的cookie可以在不同的浏览器进程间共享，比如两个IE窗口。而对于保存在内存的cookie，不同的浏览器有不同的处理方式。可以类比于本地存储的localstore cookie的操作1、 cookie的发送： 服务器端像客户端发送Cookie是通过HTTP响应报文实现的，在Set-Cookie中设置需要像客户端发送的cookie，cookie格式如下：1·Set-Cookie: &quot;name=value;domain=.domain.com;path=/;expires=Sat, 11 Jun 2016 11:29:42 GMT;HttpOnly;secure&quot; 其中name=value是必选项，其它都是可选项。 客户端的话用js即可操作，由于现在客户端设置大部分用H5的本地存储localstore和sessionstore多一点，所以客户端的这里不做介绍 2、cookie的读取 这里介绍的js来读取cookie，可以直接使用下面的方法，其实就是用document.cookie：12345678910111213function getCookie(name)&#123; var cookieName=encodeURIComponent(name)+\"=\", cookieStart=document.cookie.indexOf(cookieName), cookieValue=null; if(cookieStart&gt;-1)&#123; var cookieEnd=document.cookie.indexOf(\";\",cookieStart); if(cookieEnd==-1)&#123; cookieEnd=document.cookie.Length; &#125; cookieValue=decodeURIComponent(document.cookie.substring(cookieStart+document.cookie.length,cookieEnd)); &#125; return cookieValue;&#125; 3、cookie的修改与删除 Cookie并不提供修改、删除操作。如果要修改某个Cookie，只需要新建一个同名的Cookie，添加到response中覆盖原来的Cookie。 如果要删除某个Cookie，只需要新建一个同名的Cookie，并将maxAge设置为0，并添加到response中覆盖原来的Cookie。注意是0而不是负数。 Cookie的实现原理 Cookie实际上是一小段的文本信息。客户端请求服务器，如果服务器需要记录该用户状态，就使用response向客户端浏览器颁发一个Cookie。客户端浏览器会把Cookie保存起来。当浏览器再请求该网站时，浏览器把请求的网址连同该Cookie一同提交给服务器。服务器检查该Cookie，以此来辨认用户状态。服务器还可以根据需要修改Cookie的内容。如下图所示： 这个跟其实跟浏览器你器缓存有点类似，具体的过程我们可以分解分解：（1）客户端在浏览器的地址栏中键入Web服务器的URL，浏览器发送读取网页的请求。（2）服务器接收到请求后，产生一个Set-Cookie报头，放在HTTP报文中一起回传客户端，发起一次会话。（3）客户端收到应答后，若要继续该次会话，则将Set-Cook-ie中的内容取出，形成一个Cookie.txt文件储存在客户端计算机里。（4）当客户端再次向服务器发出请求时，浏览器先在电脑里寻找对应该网站的Cookie.txt文件。如果找到，则根据此Cookie.txt产生Cookie报头，放在HTTP请求报文中发给服务器。（5）服务器接收到包含Cookie报头的请求，检索其Cookie中与用户有关的信息，生成一个客户端所请示的页面应答传递给客户端。 浏览器的每一次网页请求，都可以传递已存在的Cookie文件，例如，浏览器的打开或刷新网页操作。 Cookie的安全问题 通常cookie信息都是使用http连接传递数据，这种传递方式很容易被查看，而且js里面直接有一个document.cookie方法，可以直接获取到用户的cooie,所以cookie存储的信息容易被窃取。假如cookie中所传递的内容比较重要，那么就要求使用加密的数据传输。 如何来防范cookie的安全呢？有以下几种方法： HttpOnly属性 如果在Cookie中设置了”HttpOnly”属性，那么通过程序(JS脚本、Applet等)将无法读取到Cookie信息，这样能有效的防止XSS攻击。 secure属性 当设置为true时，表示创建的 Cookie 会被以安全的形式向服务器传输，也就是只能在 HTTPS 连接中被浏览器传递到服务器端进行会话验证，如果是 HTTP 连接则不会传递该信息，所以不会被盗取到Cookie 的具体内容。 我们再来看看一道经典的面试题：登录时候用cookie的话，安全性问题怎么解决？这个问题，网上找了比较久的答案，比较满意的有两种答案（答案是网上找的） 第1种是：把用户对象（包含了用户ID、用户名、是否登录..）序列化成字符串再加密存入Cookie。密钥是：客户端IP+浏览器Agent+用户标识+固定的私有密钥当cookie被窃取后，只要任一信息不匹配，就无法解密cookie，进而也就不能登录了。这样做的缺点是IP不能变动、频繁加密解密会加重CPU负担 第2种是：将用户的认证信息保存在一个cookie中，具体如下： cookie名：uid。推荐进行加密，比如MD5(‘站点名称’)等。 cookie值：登录名|有效时间Expires|hash值。hash值可以由”登录名+有效时间Expires+用户密码（加密后的）的前几位 +salt” (salt是保证在服务器端站点配置文件中的随机数)这样子设计有以下几个优点：1.即使数据库被盗了，盗用者还是无法登录到系统，因为组成cookie值的salt是保证在服务器站点配置文件中而非数据 库。2.如果账户被盗了，用户修改密码，可以使盗用者的cookie值无效。3.如果服务器端的数据库被盗了，通过修改salt值可以使所有用户的cookie值无效，迫使用户重新登录系统。4.有效时间Expires可以设置为当前时间+过去时间（比如2天），这样可以保证每次登录的cookie值都不一样，防止盗用者 窥探到自己的cookie值后作为后门，长期登录。 cookie跨地址，跨域问题以及解决方案 cookie是不能跨域访问的，那么，假如需要跨域来进行cookie的访问和传递，该怎么办呢？查找了比较多的资料，比较少这方面的资料， 在cookie跨域这个问题上，前端能做的不多，很多都是需要和后端一起配合来完成。 总结了下面的几种方法，具体的实现过程这里没有写，可以点击我提供的链接自己看看。 前2种具体的实现方法可以点击看这里:点我1、nginx方向代理： 反向代理（Reverse Proxy）方式是指以代理服务器来接受Internet上的连接请求，然后将请求转发给内部网络上的服务器；并将从服务器上得到的结果返回给Internet上请求连接的客户端，此时代理服务器对外就表现为一个服务器。 反向代理服务器对于客户端而言它就像是原始服务器，并且客户端不需要进行任何特别的设置。客户端向反向代理 的命名空间(name-space)中的内容发送普通请求，接着反向代理将判断向何处(原始服务器)转交请求，并将获得的内容返回给客户端，就像这些内容 原本就是它自己的一样。2、jsonp方法： 这个方法和我们平时处理js跨域的jsonp方法一样。具体实现方法可以看看淘宝的解决方法，点我 3、nodejs的superagent4、iframe方法：比如有个www.a.com/index.html的页面，往www.b.com/index.html的页面传递cookiewww.a.com/index.html这样写：1234567891011121314151617181920&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;我是a页面&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;/body&gt;&lt;script type=\"text/javascript\"&gt;document.cookie = \"name=\" + \"value;\" + \"expires=\" + \"datatime;\" + \"domain=\" + \"\" + \"path=\" + \"/path\" + \"; secure\";//name Cookie名字//value Cookie值//expires 有效期截至(单位毫秒)//path 子目录//domain 有效域//secure 是否安全window.location = \"http://www.b.com/index.html?\" + document.cookie; //跳转到b页面&lt;/script&gt;&lt;/html&gt; www.b.com/index.html 这样写： &lt;!DOCTYPE html&gt; &lt;html lang=\"en\"&gt; &lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;我是b页面&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;iframe src='http://www.a.com/index.html' width='100' height='100' style=\"display:none\"&gt;&lt;/iframe&gt; &lt;/body&gt; &lt;script type=\"text/javascript\"&gt; var url = window.location.toString();//获取地址 var get = url.substring(url.indexOf(\"abc\"));//获取变量和变量值 var idx = get.indexOf(\"=\");//获取变量名长度 if (idx != -1) { var name = get.substring(0, idx);//获取变量名 var val = get.substring(idx + 1);//获取变量值 setCookie(name, val, 1);//创建Cookie } &lt;/script&gt; &lt;/html&gt; 备注：本文主要是查找了网上比较多的资料来总结cookie的一些知识，文笔有限，有误之处，欢迎指出","tags":[{"name":"博客园迁移","slug":"博客园迁移","permalink":"https://xianyulaodi.github.io/tags/博客园迁移/"},{"name":"cookie","slug":"cookie","permalink":"https://xianyulaodi.github.io/tags/cookie/"}]}]